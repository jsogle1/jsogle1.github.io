<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Moon Phase Calculator (Century Anchors)</title>

  <style>
    body {
      max-width: 900px;
      margin: 2rem auto;
      padding: 0 1rem;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      line-height: 1.45;
    }
    h1, h2 { line-height: 1.15; }
    a { text-decoration: none; }
    a:hover { text-decoration: underline; }

    .card {
      border: 1px solid #ddd;
      border-radius: 10px;
      padding: 1rem;
      margin: 1rem 0;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(6, minmax(0, 1fr));
      gap: 0.75rem;
    }
    .span2 { grid-column: span 2; }
    .span3 { grid-column: span 3; }
    .span6 { grid-column: span 6; }

    label {
      display: block;
      font-size: 0.9rem;
      margin-bottom: 0.25rem;
    }
    input, select, button {
      width: 100%;
      padding: 0.55rem;
      font-size: 1rem;
    }
    button { cursor: pointer; }

    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .muted { color: #555; }

    @media (max-width: 720px) {
      .grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
      .span2, .span3, .span6 { grid-column: span 2; }
    }
  </style>
</head>

<body>
  <h1>Moon Phase Calculator</h1>
  <p><a href="./">← Mythos and Monarchs</a></p>

  <div class="card">
    <h2>How this stays stable across centuries</h2>
    <p class="muted">
      This uses a synodic-month cycle anchored to a known <b>solar eclipse</b> instant (New Moon),
      with one anchor per century and an <b>Auto</b> mode that picks the nearest anchor.
      Catalog times are given in dynamical time (TD) with ΔT, using ΔT = TD − UT for conversion.
    </p>
  </div>

  <div class="card">
    <h2>Calculate</h2>

    <div class="grid">
      <div class="span3">
        <label>Input Calendar</label>
        <select id="calendar">
          <option value="julian" selected>Julian (medieval England)</option>
          <option value="gregorian">Gregorian (proleptic)</option>
        </select>
      </div>

      <div class="span3">
        <label>Anchor Century</label>
        <select id="anchorSelect"></select>
      </div>

      <div class="span2">
        <label>Year</label>
        <input id="year" type="number" value="1314">
      </div>

      <div class="span2">
        <label>Month</label>
        <input id="month" type="number" min="1" max="12" value="6">
      </div>

      <div class="span2">
        <label>Day</label>
        <input id="day" type="number" min="1" max="31" value="23">
      </div>

      <div class="span2">
        <label>Hour (UTC)</label>
        <input id="hour" type="number" min="0" max="23" value="12">
      </div>

      <div class="span2">
        <label>Minute (UTC)</label>
        <input id="minute" type="number" min="0" max="59" value="0">
      </div>

      <div class="span6">
        <button id="btn">Compute moon phase</button>
      </div>
    </div>

    <p class="muted">
      Tip: for date-only writing, keep <b>12:00 UTC</b> to avoid day-boundary weirdness.
    </p>
  </div>

  <div class="card">
    <h2>Result</h2>
    <div id="out">Enter a date and compute.</div>
  </div>

  <script>
    // =======================
    // Core constants
    // =======================
    const SYNODIC_MONTH = 29.530588853;

    function mod(n, m) { return ((n % m) + m) % m; }
    function deg2rad(d) { return d * Math.PI / 180; }

    // =======================
    // Calendar date -> Julian Day
    // =======================
    function julianDay(y, m, d, h, min, s, cal) {
      let Y = y, M = m;
      if (M <= 2) { Y--; M += 12; }

      const A = Math.floor(Y / 100);
      const B = (cal === "gregorian") ? (2 - A + Math.floor(A / 4)) : 0;

      const frac = (h + min / 60 + s / 3600) / 24;

      return Math.floor(365.25 * (Y + 4716))
           + Math.floor(30.6001 * (M + 1))
           + d + frac + B - 1524.5;
    }

    // =======================
    // Convert catalog TD time + ΔT seconds -> UT clock time
    // ΔT = TD - UT  =>  UT = TD - ΔT
    // =======================
    function tdToUt(h, m, s, deltaTSeconds) {
      // deltaTSeconds can be positive or negative (modern tables sometimes show -0/-1)
      let total = h * 3600 + m * 60 + s;
      total = total - deltaTSeconds;

      // wrap into 0..86399 and return hh:mm:ss plus dayShift
      const dayShift = Math.floor(total / 86400);
      total = ((total % 86400) + 86400) % 86400;

      const hh = Math.floor(total / 3600);
      const mm = Math.floor((total % 3600) / 60);
      const ss = Math.floor(total % 60);
      return { hh, mm, ss, dayShift };
    }

    // =======================
    // Century anchors (solar eclipses => New Moon)
    // Each entry: date + TD clock + ΔT seconds from NASA century tables.
    // We convert TD to UT inside the page so the anchor JD is correct.
    // =======================
    const ANCHORS = [
      // 1001-1100: 1001 Mar 27 19:20:56 TD, ΔT 1556s
      { key: "1000s", label: "1000s (anchor: 1001-03-27)", y:1001,m:3,d:27, tdH:19,tdM:20,tdS:56, dt:1556, cal:"julian" },

      // 1101-1200: 1101 Apr 30 03:29:14 TD, ΔT 1074s
      { key: "1100s", label: "1100s (anchor: 1101-04-30)", y:1101,m:4,d:30, tdH:3,tdM:29,tdS:14, dt:1074, cal:"julian" },

      // 1201-1300: 1201 Jan 06 15:24:30 TD, ΔT 726s
      { key: "1200s", label: "1200s (anchor: 1201-01-06)", y:1201,m:1,d:6, tdH:15,tdM:24,tdS:30, dt:726, cal:"julian" },

      // 1301-1400: 1301 Feb 09 17:06:50 TD, ΔT 484s
      { key: "1300s", label: "1300s (anchor: 1301-02-09)", y:1301,m:2,d:9, tdH:17,tdM:6,tdS:50, dt:484, cal:"julian" },

      // 1401-1500: 1401 Mar 15 02:42:43 TD, ΔT 316s
      { key: "1400s", label: "1400s (anchor: 1401-03-15)", y:1401,m:3,d:15, tdH:2,tdM:42,tdS:43, dt:316, cal:"julian" },

      // 1501-1600: 1501 Apr 17 16:15:52 TD, ΔT 194s
      { key: "1500s", label: "1500s (anchor: 1501-04-17)", y:1501,m:4,d:17, tdH:16,tdM:15,tdS:52, dt:194, cal:"julian" },

      // 1601-1700: 1601 Jan 04 12:24:38 TD, ΔT 117s
      { key: "1600s", label: "1600s (anchor: 1601-01-04)", y:1601,m:1,d:4, tdH:12,tdM:24,tdS:38, dt:117, cal:"gregorian" /* NASA uses Gregorian after 1582-10-15 */ },

      // 1701-1800: 1701 Feb 07 23:04:53 TD, ΔT 8s
      { key: "1700s", label: "1700s (anchor: 1701-02-07)", y:1701,m:2,d:7, tdH:23,tdM:4,tdS:53, dt:8, cal:"gregorian" },

      // 1801-1900: 1801 Mar 14 15:45:35 TD, ΔT 13s
      { key: "1800s", label: "1800s (anchor: 1801-03-14)", y:1801,m:3,d:14, tdH:15,tdM:45,tdS:35, dt:13, cal:"gregorian" },

      // 1901-2000: 1901 May 18 05:33:48 TD, ΔT -1s (table shows -1)
      { key: "1900s", label: "1900s (anchor: 1901-05-18)", y:1901,m:5,d:18, tdH:5,tdM:33,tdS:48, dt:-1, cal:"gregorian" },

      // 2001-2100: 2001 Jun 21 12:04:46 TD, ΔT 64s
      { key: "2000s", label: "2000s (anchor: 2001-06-21)", y:2001,m:6,d:21, tdH:12,tdM:4,tdS:46, dt:64, cal:"gregorian" },
    ];

    function anchorJD(anchor) {
      const ut = tdToUt(anchor.tdH, anchor.tdM, anchor.tdS, anchor.dt);

      // adjust date if UT conversion crosses midnight
      let y = anchor.y, m = anchor.m, d = anchor.d;
      if (ut.dayShift !== 0) {
        // Minimal day-shift handling without a full calendar library:
        // Convert anchor date at 12:00 to JD, add dayShift, then convert back by JD math? Not needed:
        // We only need JD of the instant. Just compute JD for (y,m,d) then add dayShift.
        const jd0 = julianDay(y, m, d, ut.hh, ut.mm, ut.ss, anchor.cal);
        return jd0 + ut.dayShift;
      }

      return julianDay(y, m, d, ut.hh, ut.mm, ut.ss, anchor.cal);
    }

    function phaseName(angleDeg) {
      const bins = [
        "New Moon",
        "Waxing Crescent",
        "First Quarter",
        "Waxing Gibbous",
        "Full Moon",
        "Waning Gibbous",
        "Last Quarter",
        "Waning Crescent"
      ];
      return bins[Math.floor(mod(angleDeg + 22.5, 360) / 45)];
    }

    function computePhase(input, anchor) {
      const JD = julianDay(input.year, input.month, input.day, input.hour, input.minute, 0, input.calendar);
      const epochJD = anchorJD(anchor);

      const ageDays = mod(JD - epochJD, SYNODIC_MONTH);
      const angle = 360 * (ageDays / SYNODIC_MONTH);
      const illumination = 0.5 * (1 - Math.cos(deg2rad(angle)));

      return { JD, epochJD, ageDays, angle, illumination };
    }

    function pickAnchorAuto(year) {
      // pick the anchor whose anchor-year is closest to the input year
      let best = ANCHORS[0], bestDist = Infinity;
      for (const a of ANCHORS) {
        const dist = Math.abs(year - a.y);
        if (dist < bestDist) { bestDist = dist; best = a; }
      }
      return best;
    }

    // =======================
    // UI wiring
    // =======================
    const $ = id => document.getElementById(id);
    const out = $("out");
    const anchorSelect = $("anchorSelect");

    // Populate dropdown
    (function initAnchors() {
      const autoOpt = document.createElement("option");
      autoOpt.value = "__auto__";
      autoOpt.textContent = "Auto (pick nearest anchor)";
      anchorSelect.appendChild(autoOpt);

      for (const a of ANCHORS) {
        const opt = document.createElement("option");
        opt.value = a.key;
        opt.textContent = a.label;
        anchorSelect.appendChild(opt);
      }
      anchorSelect.value = "__auto__";
    })();

    function getSelectedAnchor(inputYear) {
      const v = anchorSelect.value;
      if (v === "__auto__") return pickAnchorAuto(inputYear);
      return ANCHORS.find(a => a.key === v) || pickAnchorAuto(inputYear);
    }

    function render() {
      const input = {
        calendar: $("calendar").value,
        year: +$("year").value,
        month: +$("month").value,
        day: +$("day").value,
        hour: +$("hour").value,
        minute: +$("minute").value
      };

      if (![input.year, input.month, input.day, input.hour, input.minute].every(Number.isFinite)) {
        out.textContent = "Please enter valid numeric values.";
        return;
      }

      const anchor = getSelectedAnchor(input.year);
      const r = computePhase(input, anchor);

      const illumPct = (r.illumination * 100);
      const ut = tdToUt(anchor.tdH, anchor.tdM, anchor.tdS, anchor.dt);

      out.innerHTML = `
        <div><b>${phaseName(r.angle)}</b></div>
        <div>Illumination: <span class="mono">${illumPct.toFixed(1)}%</span></div>
        <div>Phase angle: <span class="mono">${r.angle.toFixed(1)}°</span> (0° = New, 180° = Full)</div>
        <div>Moon age: <span class="mono">${r.ageDays.toFixed(2)}</span> days</div>

        <hr style="border:none;border-top:1px solid #eee;margin:0.9rem 0;">

        <div class="muted">
          <b>Anchor used:</b> <span class="mono">${anchor.label}</span><br>
          Catalog time: TD <span class="mono">${String(anchor.tdH).padStart(2,"0")}:${String(anchor.tdM).padStart(2,"0")}:${String(anchor.tdS).padStart(2,"0")}</span>,
          ΔT <span class="mono">${anchor.dt}s</span>,
          UT ≈ <span class="mono">${String(ut.hh).padStart(2,"0")}:${String(ut.mm).padStart(2,"0")}:${String(ut.ss).padStart(2,"0")}</span>
          (${anchor.cal})
        </div>

        <div class="muted" style="margin-top:0.4rem;">
          JD (date): <span class="mono">${r.JD.toFixed(5)}</span> ·
          JD (anchor): <span class="mono">${r.epochJD.toFixed(5)}</span> ·
          Input calendar: <span class="mono">${input.calendar}</span> ·
          UTC: <span class="mono">${String(input.hour).padStart(2,"0")}:${String(input.minute).padStart(2,"0")}</span>
        </div>
      `;
    }

    $("btn").addEventListener("click", render);
    render();
  </script>
</body>
</html>
