<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Moon Phase Calculator (Meeus Polynomial - Enhanced)</title>

  <style>
    body { max-width: 900px; margin: 2rem auto; padding: 0 1rem; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; line-height: 1.45; }
    h1, h2 { line-height: 1.15; }
    a { text-decoration: none; }
    a:hover { text-decoration: underline; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 1rem; margin: 1rem 0; }
    .grid { display: grid; grid-template-columns: repeat(6, minmax(0, 1fr)); gap: 0.75rem; }
    .span2 { grid-column: span 2; }
    .span3 { grid-column: span 3; }
    .span6 { grid-column: span 6; }
    label { display: block; font-size: 0.9rem; margin-bottom: 0.25rem; }
    input, select, button { width: 100%; padding: 0.55rem; font-size: 1rem; }
    button { cursor: pointer; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .muted { color: #555; }
    @media (max-width: 720px) { .grid { grid-template-columns: repeat(2, minmax(0, 1fr)); } .span2, .span3, .span6 { grid-column: span 2; } }
  </style>
</head>

<body>
  <h1>Moon Phase Calculator (Meeus Polynomial - Enhanced)</h1>
  <p><a href="./">← Mythos and Monarchs</a></p>

  <div class="card">
    <h2>Accuracy notes for your series</h2>
    <p class="muted">
      Analytic Meeus method (Astronomical Algorithms Ch. 49) with extended corrections.<br>
      New/full moon timing usually accurate to minutes over 1000–3000 years.<br>
      ΔT approximated for medieval dates (~ +20 min to +2 h shift from TT to UT).<br>
      Handles Julian/proleptic Gregorian seamlessly.
    </p>
  </div>

  <div class="card">
    <h2>Calculate</h2>
    <div class="grid">
      <div class="span3">
        <label>Input Calendar</label>
        <select id="calendar">
          <option value="julian" selected>Julian (medieval England)</option>
          <option value="gregorian">Gregorian (proleptic)</option>
        </select>
      </div>
      <div class="span2"><label>Year</label><input id="year" type="number" value="1314"></div>
      <div class="span2"><label>Month</label><input id="month" type="number" min="1" max="12" value="6"></div>
      <div class="span2"><label>Day</label><input id="day" type="number" min="1" max="31" value="23"></div>
      <div class="span2"><label>Hour (UTC)</label><input id="hour" type="number" min="0" max="23" value="12"></div>
      <div class="span2"><label>Minute (UTC)</label><input id="minute" type="number" min="0" max="59" value="0"></div>
      <div class="span6"><button id="btn">Compute moon phase</button></div>
    </div>
    <p class="muted">Tip: Use 12:00 UTC for date-only scenes to avoid edge effects.</p>
  </div>

  <div class="card">
    <h2>Result</h2>
    <div id="out">Enter a date and compute.</div>
  </div>

  <script>
    function mod(n, m) { return ((n % m) + m) % m; }
    function deg2rad(d) { return d * Math.PI / 180; }

    // Better ΔT approximation (seconds); piecewise for better medieval fit
    function approxDeltaT(year) {
      const t = year - 2000;
      if (year < 948) return 2177 + 410 * (year - 948)/100; // rough extrapolation
      if (year < 1600) return 20 + 32 * ((year - 1900)/100)**2; // Espenak-style pre-1900
      if (year < 1900) return -20 + 32 * ((year - 1900)/100)**2;
      if (year < 2100) return 62.92 + 0.32217 * t + 0.005589 * t**2;
      return 62.92 + 0.32217 * t; // extrapolate
    }

    function julianDay(y, m, d, h=0, min=0, s=0, cal="julian") {
      let Y = y, M = m;
      if (M <= 2) { Y--; M += 12; }
      const A = Math.floor(Y / 100);
      const B = (cal === "gregorian") ? (2 - A + Math.floor(A / 4)) : 0;
      const frac = (h + min / 60 + s / 3600) / 24;
      return Math.floor(365.25 * (Y + 4716)) + Math.floor(30.6001 * (M + 1)) + d + frac + B - 1524.5;
    }

    function nearestNewMoonJDE(jdTT) {
      let k = (jdTT - 2451550.09766) / 29.530588861;
      let bestJDE = 0, minDiff = Infinity;

      for (let dk = -2; dk <= 2; dk++) {
        const kk = Math.floor(k) + dk;
        const T = kk / 1236.85;

        let JDE = 2451550.09766 + kk * 29.530588861
                + 0.00015437 * T*T - 0.000000150 * T*T*T + 0.00000000073 * T*T*T*T;

        const E = 1 - 0.002516 * T - 0.0000074 * T*T;
        const M  = deg2rad(mod(359.2242 + 29.10535608 * kk - 0.0000333 * T*T - 0.00000347 * T*T*T, 360));
        const M_ = deg2rad(mod(306.0253 + 385.81691806 * kk + 0.0107306 * T*T + 0.00001236 * T*T*T, 360));
        const F  = deg2rad(mod(21.2964 + 390.67050646 * kk - 0.0016528 * T*T - 0.00000239 * T*T*T, 360));
        const D  = deg2rad(mod(297.85036 + 445267.11148 * kk - 0.0017696 * T*T + 0.000003308 * T*T*T, 360)); // added D for better terms

        let corr = 0;
        corr += -0.40720          * Math.sin(M_);
        corr +=  0.17241 * E      * Math.sin(M);
        corr +=  0.01608          * Math.sin(2 * F);
        corr += -0.01039          * Math.sin(2 * M_);
        corr +=  0.00739 * E      * Math.sin(M - M_);
        corr += -0.00514 * E      * Math.sin(M + M_);
        corr +=  0.00209 * E*E    * Math.sin(2 * M);
        corr += -0.00111          * Math.sin(M_ - 2 * F);
        corr += -0.00089          * Math.sin(M + 2 * F);
        corr +=  0.00044 * E      * Math.sin(M - 2 * M_);
        corr += -0.00029          * Math.sin(2 * M_ - F);
        corr += -0.00023          * Math.sin(2 * M_ + F);
        corr +=  0.00020          * Math.sin(M + M_ - F);
        corr +=  0.00017          * Math.sin(M - M_ - F);
        corr += -0.00017          * Math.sin(D);
        corr += -0.00016          * Math.sin(2 * F - M_);
        corr +=  0.00015          * Math.sin(M + 2 * F);
        corr +=  0.00012          * Math.sin(2 * D);
        corr +=  0.00011          * Math.sin(M_ + 2 * F);
        corr +=  0.000046         * Math.sin(2 * D - M_);
        // More terms can be added from Meeus for sub-minute precision

        JDE += corr;

        const diff = Math.abs(jdTT - JDE);
        if (diff < minDiff) { minDiff = diff; bestJDE = JDE; }
      }
      return bestJDE;
    }

    function phaseName(angleDeg) {
      const bins = ["New Moon", "Waxing Crescent", "First Quarter", "Waxing Gibbous",
                    "Full Moon", "Waning Gibbous", "Last Quarter", "Waning Crescent"];
      return bins[Math.floor(mod(angleDeg + 22.5, 360) / 45)];
    }

    function computePhase(input) {
      const JD_UT = julianDay(input.year, input.month, input.day, input.hour, input.minute, 0, input.calendar);
      const deltaT_sec = approxDeltaT(input.year);
      const JD_TT = JD_UT + deltaT_sec / 86400;
      const newMoonJDE = nearestNewMoonJDE(JD_TT);
      const ageDays = mod(JD_TT - newMoonJDE, 29.530588853);
      const angle = 360 * (ageDays / 29.530588853);
      const illumination = 0.5 * (1 - Math.cos(deg2rad(angle)));

      return { JD_UT, newMoonJDE, ageDays, angle, illumination, deltaT_sec };
    }

    const $ = id => document.getElementById(id);
    const out = $("out");

    function render() {
      const input = {
        calendar: $("calendar").value,
        year: +$("year").value,
        month: +$("month").value,
        day: +$("day").value,
        hour: +$("hour").value,
        minute: +$("minute").value
      };

      if (![input.year, input.month, input.day, input.hour, input.minute].every(Number.isFinite)) {
        out.textContent = "Please enter valid numeric values.";
        return;
      }

      const r = computePhase(input);
      const illumPct = (r.illumination * 100).toFixed(1);
      const approxUT_new = (r.newMoonJDE - r.deltaT_sec / 86400).toFixed(5);

      out.innerHTML = `
        <div><b>${phaseName(r.angle)}</b></div>
        <div>Illumination: <span class="mono">${illumPct}%</span></div>
        <div>Phase angle: <span class="mono">${r.angle.toFixed(1)}°</span> (0° new, 180° full)</div>
        <div>Moon age: <span class="mono">${r.ageDays.toFixed(2)}</span> days since new moon</div>

        <hr style="border:none;border-top:1px solid #eee;margin:0.9rem 0;">

        <div class="muted">
          Nearest new moon (JDE/TT): <span class="mono">${r.newMoonJDE.toFixed(5)}</span><br>
          Approx UT of new moon: JD <span class="mono">${approxUT_new}</span> (ΔT ≈ ${Math.round(r.deltaT_sec)} s)<br>
          Input JD (UT): <span class="mono">${r.JD_UT.toFixed(5)}</span> · Calendar: ${input.calendar}
        </div>
      `;
    }

    $("btn").addEventListener("click", render);
    render();
  </script>
</body>
</html>
